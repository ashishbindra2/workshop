# Python Interview

Why Should You Hire Me?
Why Did You Leave Your Last Job?
Why Should We Hire You?

## Why Python?

Python is an interpreted language

- Dynamic
- High-level programming language

Interpreded?

- An interpreter allows the code to run line by line rather than being compiled into machine language

Dynamic: Type of the cariable is determined only during runtime
High level: python is easy to read mange meomery for you, works on any system

## **Q1. Difference Between List and Tuple in Python**

| **Aspect**           | **List**                             | **Tuple**                           |
|-----------------------|---------------------------------------|--------------------------------------|
| **Definition**        | List is a Group of Comma separeated Values within Square Brackets and Square Brackets are mandatory. Eg: `i = [10, 20, 30, 40]`.        | Tuple is a Group of Comma separeated Values within Parenthesis and Parenthesis are optional. Eg: `t = (10, 20, 30, 40)` `t = 10, 20, 30, 40.`     |
| **Syntax**            | Defined using square brackets: `[ ]` | Defined using parentheses: `( )`    |
| **Mutability**        | Mutable: Can add, remove, or modify elements. | Immutable: Cannot change after creation. |
| **Performance**       | Slower due to mutability.            | Faster due to immutability.         |
| **Use Case**          | Suitable for collections that may change. | Suitable for fixed collections (e.g., coordinates). |
| **Size**              | Can dynamically grow or shrink.      | Fixed size once created.            |
| **Methods**           | Supports methods like `.append()`, `.remove()`, `.sort()`. | Limited methods: Only `.count()` and `.index()`. |
| **Memory Usage**      | Requires more memory due to dynamic resizing. | More memory-efficient.              |
| **Hashability**       | Not hashable; cannot be used as dictionary keys. | Hashable if all elements are hashable. |
| **Examples**          | `my_list = [1, 2, 3]`               | `my_tuple = (1, 2, 3)`              |

---

### **Key Points**

1. **Mutability**:
   - Lists are mutable, making them ideal for scenarios where data might need to change.
   - Tuples are immutable, ensuring data integrity and better performance in some cases.

2. **When to Use**:
   - Use **lists** when flexibility is needed (e.g., managing a collection of user inputs).
   - Use **tuples** for fixed data (e.g., coordinates, configuration constants).

3. **Hashable Tuples**:
   - A tuple can be used as a key in a dictionary if all its elements are hashable.

---

### **Example: List**

```python
my_list = [1, 2, 3]
my_list.append(4)  # Adds 4 to the list
print(my_list)  # Output: [1, 2, 3, 4]
```

### **Example: Tuple**

```python
my_tuple = (1, 2, 3)
# my_tuple[0] = 10  # Raises a TypeError because tuples are immutable
print(my_tuple)  # Output: (1, 2, 3)
```

In Python, the term **"hashable"** is used to describe an object that has a hash value that remains constant during its lifetime. In the context of dictionaries, hashable objects are critical because they are used as **keys**.

---

### **Q2. What Does Hashable Mean?**

1. **Hash Value**:  
   A hash value is a fixed-size integer that uniquely identifies an object, generated by the `hash()` function.  

2. **Immutability**:  
   To be hashable, an object must be immutable. This ensures that its hash value does not change over time, which is a key requirement for dictionary keys.

3. **Equality and Hashing**:  
   Hashable objects must implement the `__hash__()` method to compute the hash value and the `__eq__()` method for equality checks. Python dictionaries use these methods to organize and retrieve keys efficiently.

---

#### **Why Hashable Is Important for Dictionaries**

- **Key Uniqueness**:  
  Dictionary keys must be unique. Python uses the hash value of a key to quickly determine where to store or find a value in the dictionary.
  
- **Efficient Lookups**:  
  The hash value allows the dictionary to find a key in **O(1)** time complexity on average.

---

#### **Hashable Objects**

Objects that are immutable (and hence hashable) include:

- **Strings**:  

  ```python
  my_dict = {"name": "Alice"}  # 'name' is hashable
  ```

- **Numbers (int, float, etc.)**:  

  ```python
  my_dict = {42: "Answer"}  # 42 is hashable
  ```

- **Tuples (if all elements are hashable)**:  

  ```python
  my_dict = {(1, 2): "coordinates"}  # (1, 2) is hashable
  ```

---

#### **Unhashable Objects**

Objects that are mutable (and hence not hashable) include:

- **Lists**:  
  Lists are mutable and cannot be used as dictionary keys.  

  ```python
  my_dict = {[1, 2]: "List"}  # Raises TypeError: unhashable type: 'list'
  ```
  
- **Sets**:  
  Like lists, sets are mutable and unhashable.  

  ```python
  my_dict = {set([1, 2]): "Set"}  # Raises TypeError
  ```

---

#### **Custom Hashable Objects**

You can make a custom object hashable by defining the `__hash__()` and `__eq__()` methods.

#### Example

```python
class MyHashableClass:
    def __init__(self, value):
        self.value = value

    def __hash__(self):
        return hash(self.value)  # Use the hash of 'value'

    def __eq__(self, other):
        return isinstance(other, MyHashableClass) and self.value == other.value

# Using custom hashable object as dictionary key
key = MyHashableClass(42)
my_dict = {key: "Custom Object"}
print(my_dict[key])  # Output: Custom Object
```

---

#### **Key Points in the Context of Dictionaries**

1. A dictionary key **must be hashable**.
2. Hashable objects allow Python to store dictionary keys in a hash table for fast lookups.
3. If you attempt to use an unhashable object as a key, Python will raise a `TypeError`.

#### Example

```python
# Hashable example
hashable_key = "name"
my_dict = {hashable_key: "Alice"}
print(my_dict[hashable_key])  # Output: Alice

# Unhashable example
unhashable_key = [1, 2, 3]  # A list
my_dict = {unhashable_key: "List"}  # Raises TypeError
```

By ensuring that objects used as dictionary keys are hashable, Python maintains the efficiency and reliability of its dictionary implementation.

## Difference between slice and indexing

Both are used to accessing element in sequence like list or string.

- Indexing is when you refer to a specific item in a sequence by its postion or index.

```py
l = [10,20,30]

# indexing
a = l[10] #  to grab a single element
print(a)

# slice
print(l[:2])
```

slice[start: stop,step]

## List comprehension

List comprehension is a neat way to create new List using a simple one line syntax

Musch more compact and readable alternative to use a traditional.

```py

# Square numbers in a range
l = [i**2 for i in range(5)]
print(l)

## even number

l = [i for i in range(5) if i%2 == 0]
```

## What is lambda in python? Why is it used?

- lambda is a small, anonymus function.
- Don't need to formally define a function.
- Used as arguments for map(), filter(), and sorted()

```py
lambda x: x*2
```

```py
numbers = [1,2,3,4,5]
sq = list(map(lambda x:x *2,numbers))
print("Double numbers:",sq)
```

## How is memory managed in python?

Handled automatically by garbage collection and a private heap space.

- Garbage collectionn: Python has a build-n garbage collector that handles circular references
- private heap: This heap contains all python objects and data strucures
- reference counting: Every object in python has a reference count, which tracks how variables or objects refer to that object.

## break and continue control folw statements

Break statement terminate the loop

```py
for num in range(19):
  if num ==5:
    print("Found 5! Exiting the loop.")
    break
    print(num)
```

Continue statement is used when you want to skip a part of the movie but watch the rest.

```py
for num in range(19):
  if num ==5:
    continue
    print(num)
```

pass

To fill up empty block

in python empty block of code will raise an error, so comes in handy to avoid that.

### negative indexing

Nagative indexes allow you to access elements from the end of a sequence.

it counting backword insted of forword.

## How do you copy an object in python?

- Assignment operator:
  It creates a reference, making both variable point to the same object in memory

  ```py
  a = [1,2,3]
  b= a
  
  b[0] =11
  
  print(b) #  [11, 2, 3]
  print(a) #  [11, 2, 3]  
  ```

- shared reference:
  Changes made through one varibale affect the other since the same memory

- Need for copy:
  To create indepedent copies, Python offers the copy module for shallow and deep copies.

1. shallow Copy: Duplicates the object but copies reference for nested objects, so changes in nested objects affect both copies.

A shallow copy helps in creating a new outer object, but if the outer object contains nested elements like a list inside another list, then it copies only the references of the object, but not the actual data. A shallow copy creates a new outer object, but if the object contains changes to nested elements, it affects both the original and the copy.

```py
from copy import copy

l1 =[1,2,[3,4],5]

# shallow copy
l2 = copy(l1)

l2[3] = 7
l2[2].append(6)

print(l2) # [1, 2, [3, 4, 6], 7]
print(l1) # [1, 2, [3, 4, 6], 7]
```

2. Deep Copy: Creates a fully independent copy, including all nested object, using deepcopy from copy module.

A deep copy creates a completely new object that includes all nested elements. Changes in the copied object will not affect the original object in any way. This method creates an entirely independent copy of the original object, including all nested objects, which means no references are shared between the original and the copied object. Any modifications in the deep copy do not affect the original object, and vice versa.

```py
from copy import deepcopy

l1 =[1,2,[3,4],5]

# shallow copy
l2 = deepcopy(l1)

l2[3] = 8
l2[2].append(6)

print(l2) # [1, 2, [3, 4, 6], 8]
print(l1) # [1, 2, [3, 4], 5]
```

## What is PEP 8 in Python?

PEP in Python stands for Python Enhancement Proposal. It comprises a collection of guidelines that outline the optimal approach for crafting and structuring Python code to improve the readability and clarity of the code. PEP 8 mainly focuses on style conventions in Python, like indentation, naming patterns, and line length, which helps in standardising code formatting.

## What does `*args` and `**kwargs` mean?

`*args` allows you to pass a variable number of postional arguments to a function. It collects these aruguments into a touple

`**kwargs` allow you to pass a variable number of keyword aruments. It collects these keyword arguments. It collects thses keyword arguments into a dictionay.

whenever we are creating a function and we are not sure total number of argument it take then we pass these two

```py
def function(*args, **kwargs):
  print(args) # ()
  print(kwargs) # {}
```

## How are arguments passed by value or by reference in python

- pass by value: Copy of the actual object is passed.
- Pass by reference: Reference to the actual object is passed.
but in python arguments are not passed by value or refrence but through "pass-by-assignment ot pass by object"

## **Q3. Difference Between `pop()` and `remove()` in Python**

| **Aspect**           | **`pop()`**                                      | **`remove()`**                                  |
|-----------------------|--------------------------------------------------|------------------------------------------------|
| **Functionality**     | Removes an element by its **index**.             | Removes an element by its **value**.           |
| **Parameters**        | Takes an optional index as an argument.          | Takes the value of the element as an argument. |
| **Return Value**      | Returns the removed element.                     | Does not return the removed element.           |
| **Default Behavior**  | If no index is provided, removes the last element. | Must specify the value to remove.              |
| **Error Handling**    | Raises an `IndexError` if the list is empty or index is out of range. | Raises a `ValueError` if the value is not found. |
| **Mutability**        | Modifies the original list.                      | Modifies the original list.                    |

---

#### **Example: `pop()`**

```python
# Using pop() with and without an index
my_list = [10, 20, 30, 40, 50]

# Remove and return the last element
removed_item = my_list.pop()
print(removed_item)  # Output: 50
print(my_list)       # Output: [10, 20, 30, 40]

# Remove and return the element at index 1
removed_item = my_list.pop(1)
print(removed_item)  # Output: 20
print(my_list)       # Output: [10, 30, 40]
```

---

#### **Example: `remove()`**

```python
# Using remove() to remove an element by value
my_list = [10, 20, 30, 40, 50]

# Remove the element with value 30
my_list.remove(30)
print(my_list)  # Output: [10, 20, 40, 50]

# Remove a value that doesn't exist (raises ValueError)
# my_list.remove(100)  # Raises ValueError: list.remove(x): x not in list
```

---

#### **Key Differences**

1. **Index vs Value**:
   - `pop()` removes an element based on its position (index).
   - `remove()` removes the first occurrence of a specific value.

2. **Return Value**:
   - `pop()` returns the removed element.
   - `remove()` does not return the removed element.

3. **Default Behavior**:
   - `pop()` without an index removes the last element.
   - `remove()` always requires a value to specify which element to remove.

---

#### **When to Use**

- Use `**pop()**` when:
  - You need to remove an element by index or retrieve the removed element.
- Use `**remove()**` when:
  - You know the value to be removed but not its index.

## Diferentiate between Sorted vs sort

1. sorted():

- Returns a new list
- Works on any iterable
- Syntax: sorted(iterable, key=None, reverse=False)

2. sort():

- Modifies the list in place
- works only on lists
- syntax: list.sort(key=None,reverse=False)

## Compile time error vs Runtime error

- compile time and runtime errors- are error that happen at different stagrs in the execution of a program.
- Compile-time error are detected before the code runs and are often related to typos or incorrect syntax
- Runtime error occur while the code is runing, usually due to issues like divding by zero or accessing out of bounds elements in a list.

## What are generator and decorators?

- Generator : returns n iterator
- they useful when dealting with large dataset or infinite sequences
- Gererators remeber their state between yield

---

- decorator: modify a function without modifying the code
- They take function as arguments
- They wrap the code or extend fuctionality of a fucntion

```py

def decore(func):
  def wrapper():
    print("yoo")
    func()
@decore
def greet():
  print("hello")
```

---

## oops

## What is the difference between abstraction and encapulation?

- Abstraction is about hiding the complexity of a system
- Focuses on 'what' raather than how
- working of brakes in cars

```py
from abc import ABC, abstractmethod

class Animal(ABC):
  @abstractmethod
  def make_sound(self):
    pass
class Dog(Animal):
  def make_sound(self):
    print("Bark")
```

---

- Encapsulation restricts access to the private cariable or methods.
- It hides certain parts of an object to protext its internal details
- Mainly concerned with secuirty and protection

```py
class Car:
  def __init__(self):
    self.__speed = 0
  def accelerate(self, value):
    self.__speed += value
  def get_speed(self):
    return self.__speed

car = Car()
car.__speed
```

## Ehst is method overriding? How is it different from method overloading?

- Method overloading: multiple methods with the same name but different parameters
- Method overriding: the child class overrides the behavior of the parent class;s method

## How does inheritance work in python

## What is the significance of self in python classes?

- self refers to the current instance of the class.
- It's automatically passed when you call amethod, but you still need to define it explicitly.
- It's what differentiates instance attributes from local variables.

## What are class methods and static methods? How are they different from instance methods?

### class Method

- work with class itself(not individual instances).
- Require cls as their first parameter.
- can modify class-level attributes

## Explain the differences between a set and a dictionary

set
--

- Unordered: The items are not stored in a specific sequence.
- Unique: No duplicates are allowed.
- Mutable: You can add or remoce items.
- Efficient lookups: Checking if an item exists in a set is very fast.

Dictionary
---

- Key-value pairs: Each element consists of a unique key and a value.
- orderd: The order of insertion i spreserves.
- Keys must be unique: You cannot have two identical keys but values can be repeated.
- Efficient looks: Searching for a value usong keys is very fast.

## What is the time complexity of inserting elements in a Linked List?

Insertion in a LinkedList can happen in three commom ways:

1. At the beginning (Head)
2. At the end(tail)
3. In the middle (At a specific position)

- At the begining (head) - O(1)
- At the end(tail) - O(N)
- In the middle (At a specific position) - O(N)

## How do you find the middle element of a linked list in one pass?

The two-pointer technique: Slow and Fast Poiner

- The slow pointer moves one steps at a time
- The fast pointer moves two steps at a time

Good question
** ## Write a fumction that takes a string as input and returns the length of the longest substring that contains no repeatng character

ex 1
input: s = "abcabcbb"
output: 3
Explanation: This answer is  "abc", with the length of 3.

ex2:
input s = "bbbbbb"
output: 1

eample 4
input: s = "pwwkew"
output: 3

explaination: The answer is "wke", with the length of 3 Notice that the answer must be a substring "pwke" is a subsequence and not a substring.

## Knapspack problem (Dp)

examp;
a =[60,100,120]
b = [10,20,30]
c =50
op = 220

ex2
a = [10,20,30,40]
b = [12,13,15,19]

c =10
op = 0

given two interger array A and B of size N which represent lues and weights aassociated with N items respectively

Given an interger C which represents knapsack capacity

out maximum valur subset of A such that sum of the weights of this subs et is smaller than or equal to c

## Asteroid collison problem(stack)

### Q4. Write a Python function that will reverse a string without using the slicing operation or reverse() function

```py title="using for loop"
def reverse_string(data: str)-> str:
  result = ""
  for char in data:
    result = char + result
  return result

reverse_string("Testing a string")
```

```py title="using while loop"
text: str = "Ashish"
def reverse_string(text: str)-> str:
    n = len(text)-1
    result = ''
    while n>=0 :
        result= result + text[n]
        n-=1
    return result
print(reverse_string(text))
```

### Q5. Write a program to delete all constants from a given string. "Python and Data Science"

```py
def return_string(data):
  vowels = 'aeiouAEIOU'
  result = ''.join([char for char in data if not char.isalpha() or char in vowels])
  return result

return_string(data ="Python and Data Science")

```

### Q6. Write a program that will find sum of all the prime between 1 to N

```py
def is_prime(number):
  for i in range(2,number):
    if(number % i ==0):
      return False
    return True

def add(number):
  total = 0
  for i in range(2,number + 1):
    if is_prime(i):
      total = total + i
  return total
print(add(10))
```

### Q7. What is a Generator in Python?

A generator in Python is a special type of iterable that produces values one at a time using the yield keyword, rather than creating and storing all values in memory at once.

- Generators are a memory-efficient way to handle large datasets or infinite sequences.

### **Creating Generators**

#### **1. Generator Function**

- Generator is a function which is responsible to generate a sequence of values.
- We can write generator functions just like ordinary functions, but it uses yield keyword to return values

A function that uses the `yield` keyword to produce values one at a time.

```python
def my_generator():
    for i in range(5):
        yield i

# Using the generator
gen = my_generator()
print(next(gen))  # Output: 0
print(next(gen))  # Output: 1

for value in gen:
    print(value)  # Output: 2, 3, 4
```

#### **2. Generator Expression**

A compact way to create a generator, similar to list comprehensions but with parentheses instead of square brackets.

```python
gen = (x**2 for x in range(5))

print(next(gen))  # Output: 0
print(next(gen))  # Output: 1

for value in gen:
    print(value)  # Output: 4, 9, 16
```

---

### **Difference Between Generators and Lists**

| **Aspect**        | **Generator**                                      | **List**                                 |
|--------------------|---------------------------------------------------|------------------------------------------|
| **Memory Usage**   | Memory-efficient; generates values on the fly.    | Stores all elements in memory.           |
| **Performance**    | Faster for large datasets or infinite sequences.  | Slower for large datasets due to memory overhead. |
| **Modification**   | Cannot modify elements once created.              | Can modify elements.                     |

---

### **Advantages of Generators**

1. **Memory Efficiency**:
   - Suitable for working with large datasets or streams of data.
2. **Improved Performance**:
   - No need to compute all elements upfront; computation happens only when needed.
3. **Simplified Code**:
   - Easily represent infinite sequences (e.g., Fibonacci series, prime numbers).

---

### **Use Case Example: Generator for Infinite Sequence**

```python
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_numbers()

print(next(gen))  # Output: 0
print(next(gen))  # Output: 1
print(next(gen))  # Output: 2
```

#### Generators vs Normal Collections wrt performance

```py

import random
import time
names = ['Sunny','Bunny','Chinny','Vinny']
subjects = ['Python','Java','Blockchain']

def people_list(num_people):
  results = []
  for i in range(num_people):
    person = {
      'id':i,
      'name': random.choice(names),
      'subject':random.choice(subjects)
    }
  results.append(person)
  return results
t1 = time.time()
people = people_list(10000000)
t2 = time.time()
print(f'Took {t2-t1}')

def people_generator(num_people):
  for i in range(num_people):
    person = {
      'id':i,
      'name': random.choice(names),
      'major':random.choice(subjects)
      }
  yield person

t1 = time.time()
people = people_generator(10000000)
t2 = time.time()

print(f'Took {t2-t1}')

```

#### Generators vs Normal Collections wrt Memory Utilization

Normal Collection:

```py
l=[x*x for x in range(10000000000000000)]
print(l[0])
```

> We will get MemoryError in this case because all these values are required to store in the memory.

Generators:

```py
g=(x*x for x in range(10000000000000000))
print(next(g))
Output: 0
```

>We won't get any MemoryError because the values won't be stored at the beginning
---

### **Conclusion**

Generators are a powerful tool for creating efficient, iterable objects that avoid memory overhead. Use them when working with large datasets, streaming data, or infinite sequences to improve performance and resource usage.

> create speed of function execting genrator

### Q8. What is decorator? Multiple decorator

### **What is a Decorator in Python?**

A **decorator** in Python is a function that modifies the behavior of another function or method. It allows you to "wrap" another function to add or alter its functionality without changing its structure or code.

---

### **How Decorators Work**

1. A decorator takes a function as an argument.
2. It defines a nested wrapper function that modifies or enhances the behavior of the original function.
3. The wrapper function is returned and replaces the original function.

#### **Syntax**

```python
@decorator_name
def function_to_decorate():
    pass
```

The `@decorator_name` syntax is equivalent to:

```python
function_to_decorate = decorator_name(function_to_decorate)
```

---

### **Single Decorator Example**

```python
# Define a decorator
def greet_decorator(func):
    def wrapper(name):
        print("Hello!")
        func(name)
        print("Goodbye!")
    return wrapper

# Apply the decorator
@greet_decorator
def say_name(name):
    print(f"My name is {name}.")

# Call the function
say_name("Ashish")
```

**Output**:

```
Hello!
My name is Ashish.
Goodbye!
```

---

### **Multiple Decorators**

You can stack multiple decorators on a single function by applying them one after the other.

#### **Example of Multiple Decorators**

```python
# Define decorators
def bold_decorator(func):
    def wrapper():
        return f"<b>{func()}</b>"
    return wrapper

def italic_decorator(func):
    def wrapper():
        return f"<i>{func()}</i>"
    return wrapper

# Apply multiple decorators
@bold_decorator
@italic_decorator
def get_text():
    return "Hello, World!"

# Call the function
print(get_text())
```

**Output**:

```
<b><i>Hello, World!</i></b>
```

**Explanation**:

1. The `italic_decorator` is applied first, wrapping the function output in `<i>`.
2. The `bold_decorator` is applied next, wrapping the result of the first decorator in `<b>`.

---

### **Key Points About Multiple Decorators**

1. **Order of Execution**:
   - Decorators are applied from the bottom to the top, but their effects are executed from the top down.
   - In the above example:
     - `italic_decorator` wraps the original function.
     - `bold_decorator` wraps the result of `italic_decorator`.

2. **Use Cases**:
   - You might stack multiple decorators for logging, validation, access control, or formatting.

---

### **Practical Use Cases of Decorators**

1. **Logging**:
   Add logging functionality to a function.

   ```python
   def log_decorator(func):
       def wrapper(*args, **kwargs):
           print(f"Calling function: {func.__name__}")
           return func(*args, **kwargs)
       return wrapper
   ```

2. **Access Control**:
   Restrict access to specific users or roles.

   ```python
   def admin_only(func):
       def wrapper(user):
           if user != "admin":
               print("Access Denied!")
           else:
               func(user)
       return wrapper

   @admin_only
   def view_admin_dashboard(user):
       print("Welcome to the admin dashboard!")
   ```

3. **Formatting Output**:
   Format the output of a function for display or use in templates.

---

Decorators are a powerful and flexible way to add functionality to your code in a clean and reusable manner. Multiple decorators help in stacking behaviors efficiently.

```py
def love(fun):
  def inner():
    return fun.__name__
  return inner
@love
def fun_test():
  print("testing")

print(fun_test())  
```

```py
def dob(fun):
  def inner(n):
    return fun(n**2)
  return inner

def calc(num):
  print(num)

@dob
def cal(num):
  print(num)

calc(11)
cal(11)
```

Q9. What is list comprehension? write some sample code? what is use of it?

### **What is List Comprehension in Python?**

List comprehension is a concise and elegant way to create lists in Python. It uses a single line of code to generate a new list by applying an expression to each item in an existing iterable.

---

### **Syntax of List Comprehension**

```python
[expression for item in iterable if condition]
```

1. **Expression**: An operation or transformation applied to each item in the iterable.
2. **Item**: The variable that takes the value of each element from the iterable.
3. **Iterable**: The data source (e.g., list, range, string, etc.).
4. **Condition (optional)**: A filtering condition that determines whether an item should be included.

---

### **Uses of List Comprehension**

1. **Simplifies Code**: Reduces multiple lines of code into one concise statement.
2. **Readable**: Improves code readability for simple list transformations.
3. **Efficient**: Faster than traditional `for` loops for small to medium-sized datasets.

---

### **Examples of List Comprehension**

#### **1. Basic List Creation**

```python
# Create a list of squares
squares = [x**2 for x in range(5)]
print(squares)  # Output: [0, 1, 4, 9, 16]
```

#### **2. With Filtering (Condition)**

```python
# Create a list of even numbers
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # Output: [0, 2, 4, 6, 8]
```

#### **3. Nested Loops**

```python
# Create a list of coordinate pairs
coordinates = [(x, y) for x in range(3) for y in range(2)]
print(coordinates)  # Output: [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]
```

#### **4. Applying a Function**

```python
# Convert all strings in a list to uppercase
words = ["hello", "world", "python"]
uppercase_words = [word.upper() for word in words]
print(uppercase_words)  # Output: ['HELLO', 'WORLD', 'PYTHON']
```

#### **5. Conditional Transformation**

```python
# Replace negative numbers with 0
nums = [-1, 2, -3, 4]
non_negative = [x if x >= 0 else 0 for x in nums]
print(non_negative)  # Output: [0, 2, 0, 4]
```

#### **6. Flattening a Nested List**

```python
# Flatten a 2D list
matrix = [[1, 2], [3, 4], [5, 6]]
flattened = [num for row in matrix for num in row]
print(flattened)  # Output: [1, 2, 3, 4, 5, 6]
```

---

### **Advantages of List Comprehension**

- Concise and expressive.
- Avoids the need for explicit loops.
- Easy to read and understand for simple operations.

---

### **When to Avoid List Comprehension**

- When the logic is complex and includes multiple conditions or operations, traditional loops may be more readable.
- For very large datasets, using list comprehension may lead to high memory usage as it creates the entire list in memory.

---

### **Summary**

List comprehension is a powerful and elegant way to generate and manipulate lists in Python. It is particularly useful for creating new lists based on existing iterables in a concise and efficient manner.

#### Q. Write a program to display unique vowels present in the given word?

```py
vowels = ['a', 'e', 'i', 'o', 'u']
word = input("Enter the word to search for vowels: ")

# Using list comprehension to find unique vowels in the word
found = [letter for letter in vowels if letter in word]

print(found)
print(f"The number of different vowels present in '{word}' is {len(found)}")

```

Q10. Write code of fibonacci series?

```py
def fib():
  a,b = 0,1
  while True:
    yield a
    a,b = b,a+b
data = fib()
for _ in range(11):
  print(next(data))
```

```py
# Fibonacci series using generator
def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Input: Number of terms
num_terms = int(input("Enter the number of terms: "))
print(f"Fibonacci series: {list(fibonacci_generator(num_terms))}")

```

Q11. What is dictionary? is this accept duplicate or not?
Q20. program to reverse dictionary key to value and value to key
Here’s a Python program to reverse the keys and values of a dictionary:

### **Program**

```python
# Original dictionary
original_dict = {
    "name": "Ashish",
    "age": 25,
    "course": "Python"
}

# Reversing the dictionary
reversed_dict = {value: key for key, value in original_dict.items()}

# Output the result
print("Original Dictionary:", original_dict)
print("Reversed Dictionary:", reversed_dict)
```

---

### **Output**

```
Original Dictionary: {'name': 'Ashish', 'age': 25, 'course': 'Python'}
Reversed Dictionary: {'Ashish': 'name', 25: 'age', 'Python': 'course'}
```

---

### **Explanation**

1. **`original_dict.items()`**: Provides an iterable of key-value pairs from the original dictionary.
2. **Dictionary Comprehension**: Swaps the keys and values by creating a new dictionary where:
   - `key` becomes `value`
   - `value` becomes `key`

---

### **Considerations**

- **Duplicate Values in the Original Dictionary**: If there are duplicate values in the original dictionary, the reversed dictionary will only keep one of the original keys (the last one processed). For example:

  ```python
  original_dict = {"a": 1, "b": 2, "c": 1}
  reversed_dict = {value: key for key, value in original_dict.items()}
  print(reversed_dict)  # Output: {1: 'c', 2: 'b'}
  ```

  The key `'a'` is overwritten by `'c'` for the value `1`.

- **Immutable Values**: Only hashable and immutable values in the original dictionary can be used as keys in the reversed dictionary. If a value is mutable (like a list), it will raise a `TypeError`.
Q21. what lambda function with example

### **What is a Lambda Function in Python?**

A **lambda function** in Python is a small, anonymous function defined using the `lambda` keyword. It can have any number of input arguments but only one expression. The result of the expression is automatically returned.

---

### **Syntax**

```python
lambda arguments: expression
```

- **`arguments`**: Input parameters, like a regular function.
- **`expression`**: The computation or operation to perform and return.

---

### **Key Characteristics**

1. Anonymous: Lambda functions don't have a name (unlike normal functions defined using `def`).
2. Single Expression: They consist of only one expression, and the result is implicitly returned.
3. Typically used for short, simple operations.

---

### **Examples**

#### **1. Simple Lambda Function**

```python
# Lambda function to add two numbers
add = lambda x, y: x + y
print(add(5, 3))  # Output: 8
```

---

#### **2. Lambda Function Inside Another Function**

```python
# Function using a lambda to square a number
def square(n):
    return (lambda x: x ** 2)(n)

print(square(4))  # Output: 16
```

---

#### **3. Using Lambda with `map()`**

```python
# Doubling all numbers in a list
nums = [1, 2, 3, 4, 5]
doubled = list(map(lambda x: x * 2, nums))
print(doubled)  # Output: [2, 4, 6, 8, 10]
```

---

#### **4. Using Lambda with `filter()`**

```python
# Filtering even numbers from a list
nums = [1, 2, 3, 4, 5]
even_nums = list(filter(lambda x: x % 2 == 0, nums))
print(even_nums)  # Output: [2, 4]
```

---

#### **5. Using Lambda with `sorted()`**

```python
# Sorting a list of tuples by the second element
data = [(1, 'b'), (2, 'a'), (3, 'c')]
sorted_data = sorted(data, key=lambda x: x[1])
print(sorted_data)  # Output: [(2, 'a'), (1, 'b'), (3, 'c')]
```

---

### **When to Use Lambda Functions**

1. For small, quick operations.
2. As an argument to functions like `map()`, `filter()`, and `sorted()`.
3. When defining functions inline without needing a formal function name.

---

### **Limitations of Lambda Functions**

1. **Single Expression**: Lambdas are limited to one expression, so they're not suitable for complex logic.
2. **No Name**: Debugging and reusability can be harder because they're anonymous.
3. **No Statements**: Cannot contain statements like `if`, `for`, or `print` (only expressions).

---

### **Comparison with Regular Function**

```python
# Regular function
def add(x, y):
    return x + y

# Equivalent lambda function
add_lambda = lambda x, y: x + y
```

Both can be used interchangeably, but lambda is concise and often used for inline or short-lived operations.

### **`map()`, `filter()`, and `sorted()` in Python**

These are built-in Python functions commonly used for applying operations to collections like lists, tuples, or sets. They allow for efficient, functional-style operations.

---

### **1. `map()`**

The `map()` function applies a given function to each item in an iterable and returns a new iterable (a `map` object).

#### **Syntax**

```python
map(function, iterable)
```

- **`function`**: A function to apply to each element of the iterable.
- **`iterable`**: The collection (like a list, tuple) whose items the function will process.

#### **Example**

```python
# Doubling each number in a list
nums = [1, 2, 3, 4]
doubled = list(map(lambda x: x * 2, nums))
print(doubled)  # Output: [2, 4, 6, 8]
```

#### **Use Cases**

- Transforming data in a collection.
- Applying mathematical or custom operations on each element.

---

### **2. `filter()`**

The `filter()` function filters elements from an iterable based on a condition defined by a function. It returns a new iterable (a `filter` object) containing elements where the function evaluates to `True`.

#### **Syntax**

```python
filter(function, iterable)
```

- **`function`**: A function that returns `True` or `False` for each element.
- **`iterable`**: The collection to filter.

#### **Example**

```python
# Filtering even numbers from a list
nums = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # Output: [2, 4, 6]
```

#### **Use Cases**

- Extracting elements that meet a specific condition.
- Filtering data like even numbers, strings that match a pattern, etc.

---

### **3. `sorted()`**

The `sorted()` function sorts the elements of an iterable and returns a new sorted list.

#### **Syntax**

```python
sorted(iterable, key=None, reverse=False)
```

- **`iterable`**: The collection to be sorted.
- **`key`** *(optional)*: A function defining the sorting logic (e.g., based on length or specific property).
- **`reverse`** *(optional)*: If `True`, sorts in descending order; otherwise, ascending (default).

#### **Example**

```python
# Sorting numbers in ascending and descending order
nums = [5, 2, 9, 1, 3]
print(sorted(nums))               # Output: [1, 2, 3, 5, 9]
print(sorted(nums, reverse=True)) # Output: [9, 5, 3, 2, 1]

# Sorting strings by length
words = ["apple", "banana", "kiwi"]
sorted_by_length = sorted(words, key=len)
print(sorted_by_length)  # Output: ['kiwi', 'apple', 'banana']
```

#### **Use Cases**

- Sorting data numerically, alphabetically, or based on custom criteria.
- Rearranging complex data like dictionaries, tuples, or custom objects.

---

### **Summary of Differences**

| **Function** | **Purpose**                                        | **Returns**       | **Use Case**                                |
|--------------|----------------------------------------------------|-------------------|---------------------------------------------|
| `map()`      | Applies a function to every element of an iterable | A `map` object    | Transform all elements of a collection      |
| `filter()`   | Filters elements based on a condition              | A `filter` object | Extract specific elements from a collection |
| `sorted()`   | Sorts elements based on criteria                   | A list            | Arrange elements in a specific order        |

These functions are integral for efficient data processing and align well with functional programming styles in Python.
Q22. Can you convert List to Dict object. (Scenario)
> Yes, you can convert a list to a dictionary in Python. However, how you do this depends on the structure of the list and the desired format of the dictionary. Here are a few common scenarios:

---

### **1. Convert a List of Tuples to a Dictionary**

If the list contains tuples where the first element is the key and the second is the value, you can use the `dict()` constructor.

```python
# List of tuples
list_of_tuples = [("a", 1), ("b", 2), ("c", 3)]

# Convert to dictionary
dict_obj = dict(list_of_tuples)
print(dict_obj)
```

**Output:**

```
{'a': 1, 'b': 2, 'c': 3}
```

---

### **2. Convert Two Lists (Keys and Values) into a Dictionary**

If you have two lists — one for keys and one for values — you can use the `zip()` function.

```python
# Lists of keys and values
keys = ["name", "age", "city"]
values = ["Alice", 25, "New York"]

# Convert to dictionary
dict_obj = dict(zip(keys, values))
print(dict_obj)
```

**Output:**

```
{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

---

### **3. Convert a List of Elements into a Dictionary with Indices as Keys**

If you want to use the indices of the list elements as dictionary keys, you can use `enumerate()`.

```python
# List of values
values = ["Apple", "Banana", "Cherry"]

# Convert to dictionary
dict_obj = {index: value for index, value in enumerate(values)}
print(dict_obj)
```

**Output:**

```
{0: 'Apple', 1: 'Banana', 2: 'Cherry'}
```

---

### **4. Convert a Flat List into a Dictionary**

If the list alternates between keys and values, you can use slicing or the `zip()` function.

```python
# Flat list with alternating keys and values
flat_list = ["name", "Alice", "age", 25, "city", "New York"]

# Convert to dictionary
dict_obj = dict(zip(flat_list[0::2], flat_list[1::2]))
print(dict_obj)
```

**Output:**

```
{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

---

### **5. Custom Conversion Logic**

If the list has a custom structure, you can use a loop or a dictionary comprehension to process it.

```python
# List of items
list_items = ["name", "Alice", "age", 25, "city", "New York"]

# Convert to dictionary (even indices are keys, odd indices are values)
dict_obj = {list_items[i]: list_items[i + 1] for i in range(0, len(list_items), 2)}
print(dict_obj)
```

**Output:**

```
{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

---

### **General Notes**

1. **Duplicate Keys**: If the list contains duplicate keys (e.g., in case of a list of tuples), only the last key-value pair is retained in the dictionary.
2. **Invalid Data Structure**: If the list structure doesn't match the intended dictionary format (e.g., an odd number of elements in the flat list), you’ll need to handle such cases with error-checking or default values.
Q23. Diff between extend & append in list

### **Difference Between `extend()` and `append()` in Python Lists**

Both `extend()` and `append()` are methods used to add elements to a list in Python, but they behave differently.

---

### **1. `append()`**

- **Purpose**: Adds a single element to the end of the list.
- **Behavior**: Treats the argument as a single item, even if it is iterable (like a list or tuple).
- **Returns**: Does not return a new list; modifies the list in place.
  
#### **Example:**

```python
# Original list
my_list = [1, 2, 3]

# Append an element
my_list.append(4)
print(my_list)  # Output: [1, 2, 3, 4]

# Append a list as a single element
my_list.append([5, 6])
print(my_list)  # Output: [1, 2, 3, 4, [5, 6]]
```

---

### **2. `extend()`**

- **Purpose**: Extends the list by appending each element from the iterable (like another list or tuple) to the list.
- **Behavior**: Breaks the iterable into individual elements and adds them to the list.
- **Returns**: Does not return a new list; modifies the list in place.

#### **Example:**

```python
# Original list
my_list = [1, 2, 3]

# Extend the list with another list
my_list.extend([4, 5])
print(my_list)  # Output: [1, 2, 3, 4, 5]

# Extend the list with a tuple
my_list.extend((6, 7))
print(my_list)  # Output: [1, 2, 3, 4, 5, 6, 7]
```

---

### **Key Differences**

| **Feature**       | **`append()`**                      | **`extend()`**                          |
|--------------------|-------------------------------------|-----------------------------------------|
| **Argument**       | Takes a single element (any type). | Takes an iterable (e.g., list, tuple).  |
| **Behavior**       | Adds the entire element as-is.     | Adds each element of the iterable.      |
| **Effect**         | Increases the list length by 1.    | Increases the list length by the size of the iterable. |
| **Result**         | Adds nested lists or iterables.    | Flattens the iterable into the list.    |

---

### **Example Comparison**

```python
# Using append()
list1 = [1, 2, 3]
list1.append([4, 5])
print(list1)  # Output: [1, 2, 3, [4, 5]]

# Using extend()
list2 = [1, 2, 3]
list2.extend([4, 5])
print(list2)  # Output: [1, 2, 3, 4, 5]
```

---

### **When to Use?**

- Use **`append()`** when you want to add a single element or when adding an entire object (like a list) as a single item.
- Use **`extend()`** when you want to add multiple elements from an iterable to the list individually.

These methods make list manipulations more versatile and efficient depending on the task.
Q13. What are the main principles of oops?
Q14. Explain type of inheritance
Q15. What is aws lambda function
Q16. Explain your project briefly
Q17. regular expression for email validation

### **Regular Expression for Email Validation**

A regular expression (regex) can be used to validate email addresses by ensuring they conform to a specific pattern. Here's an example of a commonly used regex for email validation:

```python
import re

# Define a regex pattern for email validation
email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

# Sample email validation function
def validate_email(email):
    if re.match(email_regex, email):
        return True
    return False

# Test the function
print(validate_email("example@test.com"))  # Output: True
print(validate_email("invalid-email"))     # Output: False
```

---

### **Explanation of the Regex Pattern**

```regex
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

| **Component**          | **Meaning**                                                                 |
|-------------------------|-----------------------------------------------------------------------------|
| `^`                    | Start of the string.                                                       |
| `[a-zA-Z0-9._%+-]+`     | Matches the local part of the email (before the `@`). Can contain letters, digits, dots (`.`), underscores (`_`), percent signs (`%`), plus (`+`), and hyphens (`-`). |
| `@`                    | Matches the `@` symbol separating the local part and the domain.            |
| `[a-zA-Z0-9.-]+`        | Matches the domain name (e.g., `gmail`, `yahoo`). Can contain letters, digits, dots (`.`), and hyphens (`-`). |
| `\.`                   | Matches the dot (`.`) separating the domain and top-level domain (TLD).     |
| `[a-zA-Z]{2,}`          | Matches the top-level domain (TLD) with at least 2 characters (e.g., `com`, `org`). |
| `$`                    | End of the string.                                                         |

---

### **Examples of Valid and Invalid Emails**

#### **Valid Emails**

1. `example@test.com`
2. `user.name+tag+sorting@example.com`
3. `x@example.org`
4. `email@subdomain.example.com`

#### **Invalid Emails**

1. `plainaddress` (No `@` symbol)
2. `@missingusername.com` (No local part)
3. `username@.com` (Domain is missing)
4. `username@domain` (No TLD)

---

### **Important Notes**

- This regex is a basic implementation and covers most use cases.
- Some valid emails might not match this regex (e.g., unusual but technically valid domain names).
- For stricter validation or internationalized email addresses, consider libraries like **`email-validator`**:

  ```bash
  pip install email-validator
  ```

  ```python
  from email_validator import validate_email, EmailNotValidError

  try:
      valid = validate_email("example@test.com")
      print("Valid Email:", valid.email)
  except EmailNotValidError as e:
      print("Invalid Email:", str(e))
  ```

Q18. How to define private and public variables
Q19. convert list to pandas dataframe

Q24. Define a class. SDLC models
Q25. Asked to describe iterators in Python, and implement it
Q26. Asked about generators? Asked how I implemented Python in my project
Q27. datatypes in python
Q28. SLice , list , dict , django, CROSS, API
Q29. Midlewares, session,cookies,APIs,oops
Q30. Reverse character string in python
Q32. map

### **`map()`, `filter()`, and `sorted()` in Python**

These are built-in Python functions commonly used for applying operations to collections like lists, tuples, or sets. They allow for efficient, functional-style operations.

---

### **1. `map()`**

The `map()` function applies a given function to each item in an iterable and returns a new iterable (a `map` object).

#### **Syntax**

```python
map(function, iterable)
```

- **`function`**: A function to apply to each element of the iterable.
- **`iterable`**: The collection (like a list, tuple) whose items the function will process.

#### **Example**

```python
# Doubling each number in a list
nums = [1, 2, 3, 4]
doubled = list(map(lambda x: x * 2, nums))
print(doubled)  # Output: [2, 4, 6, 8]
```

#### **Use Cases**

- Transforming data in a collection.
- Applying mathematical or custom operations on each element.

---

### **2. `filter()`**

The `filter()` function filters elements from an iterable based on a condition defined by a function. It returns a new iterable (a `filter` object) containing elements where the function evaluates to `True`.

#### **Syntax**

```python
filter(function, iterable)
```

- **`function`**: A function that returns `True` or `False` for each element.
- **`iterable`**: The collection to filter.

#### **Example**

```python
# Filtering even numbers from a list
nums = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # Output: [2, 4, 6]
```

#### **Use Cases**

- Extracting elements that meet a specific condition.
- Filtering data like even numbers, strings that match a pattern, etc.

---

### **3. `sorted()`**

The `sorted()` function sorts the elements of an iterable and returns a new sorted list.

#### **Syntax**

```python
sorted(iterable, key=None, reverse=False)
```

- **`iterable`**: The collection to be sorted.
- **`key`** *(optional)*: A function defining the sorting logic (e.g., based on length or specific property).
- **`reverse`** *(optional)*: If `True`, sorts in descending order; otherwise, ascending (default).

#### **Example**

```python
# Sorting numbers in ascending and descending order
nums = [5, 2, 9, 1, 3]
print(sorted(nums))               # Output: [1, 2, 3, 5, 9]
print(sorted(nums, reverse=True)) # Output: [9, 5, 3, 2, 1]

# Sorting strings by length
words = ["apple", "banana", "kiwi"]
sorted_by_length = sorted(words, key=len)
print(sorted_by_length)  # Output: ['kiwi', 'apple', 'banana']
```

#### **Use Cases**

- Sorting data numerically, alphabetically, or based on custom criteria.
- Rearranging complex data like dictionaries, tuples, or custom objects.

---

### **Summary of Differences**

| **Function** | **Purpose**                                        | **Returns**       | **Use Case**                                |
|--------------|----------------------------------------------------|-------------------|---------------------------------------------|
| `map()`      | Applies a function to every element of an iterable | A `map` object    | Transform all elements of a collection      |
| `filter()`   | Filters elements based on a condition              | A `filter` object | Extract specific elements from a collection |
| `sorted()`   | Sorts elements based on criteria                   | A list            | Arrange elements in a specific order        |

These functions are integral for efficient data processing and align well with functional programming styles in Python.x  
Q33. filter
Q34. tertools (Advanced Iterators)

### **`itertools` (Advanced Iterators) in Python**

The **`itertools`** module in Python provides a set of fast, memory-efficient tools for working with iterators. These tools allow you to create complex iterators for handling combinatorics, permutations, combinations, and more. It's part of Python's standard library.

---

### **Key Features**

1. Efficient iteration over large data sets without loading everything into memory.
2. Provides advanced functions for:
   - Infinite iterators
   - Iterators for combinations and permutations
   - Utility functions for iterator manipulation

---

### **Categories of Functions**

#### **1. Infinite Iterators**

These iterators produce values indefinitely and are useful for repetitive tasks.

- **`itertools.count(start=0, step=1)`**: Generates an infinite sequence starting at `start` and incremented by `step`.

  ```python
  from itertools import count
  for num in count(5, 2):  # Starts at 5, increments by 2
      if num > 15:
          break
      print(num)  # Output: 5, 7, 9, 11, 13, 15
  ```

- **`itertools.cycle(iterable)`**: Cycles through an iterable indefinitely.

  ```python
  from itertools import cycle
  counter = 0
  for item in cycle(['A', 'B', 'C']):
      if counter > 5:
          break
      print(item)  # Output: A, B, C, A, B, C
      counter += 1
  ```

- **`itertools.repeat(object, times=None)`**: Repeats an object a fixed number of times (or indefinitely if `times` is not specified).

  ```python
  from itertools import repeat
  for item in repeat("Hello", 3):
      print(item)  # Output: Hello, Hello, Hello
  ```

---

#### **2. Combinatoric Iterators**

Generate permutations, combinations, or Cartesian products.

- **`itertools.permutations(iterable, r=None)`**: Generates all possible permutations of `r` elements from the iterable.

  ```python
  from itertools import permutations
  for perm in permutations([1, 2, 3], 2):
      print(perm)  # Output: (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)
  ```

- **`itertools.combinations(iterable, r)`**: Generates all possible combinations of `r` elements from the iterable.

  ```python
  from itertools import combinations
  for comb in combinations([1, 2, 3], 2):
      print(comb)  # Output: (1, 2), (1, 3), (2, 3)
  ```

- **`itertools.product(*iterables, repeat=1)`**: Generates the Cartesian product of input iterables.

  ```python
  from itertools import product
  for prod in product([1, 2], ['A', 'B']):
      print(prod)  # Output: (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')
  ```

---

#### **3. Utility Iterators**

Helpers for combining, grouping, or slicing iterators.

- **`itertools.chain(*iterables)`**: Combines multiple iterables into a single iterator.

  ```python
  from itertools import chain
  for item in chain([1, 2], ['A', 'B']):
      print(item)  # Output: 1, 2, A, B
  ```

- **`itertools.islice(iterable, start, stop, step)`**: Slices an iterable.

  ```python
  from itertools import islice
  for item in islice(range(10), 2, 8, 2):
      print(item)  # Output: 2, 4, 6
  ```

- **`itertools.groupby(iterable, key=None)`**: Groups items in an iterable by a key function.

  ```python
  from itertools import groupby
  data = [("cat", 1), ("cat", 2), ("dog", 3), ("dog", 4)]
  for key, group in groupby(data, lambda x: x[0]):
      print(key, list(group))  
      # Output: 
      # cat [('cat', 1), ('cat', 2)]
      # dog [('dog', 3), ('dog', 4)]
  ```

---

### **Advantages**

1. **Memory Efficiency**: Operates lazily, producing values on demand instead of storing them in memory.
2. **Combinatoric Power**: Simplifies tasks like generating permutations, combinations, or Cartesian products.
3. **Enhanced Productivity**: Provides many ready-to-use tools that reduce the need for custom implementations.

---

### **Real-World Example**

**Summing two lists element-wise using `itertools.zip_longest`:**

```python
from itertools import zip_longest

list1 = [1, 2, 3]
list2 = [4, 5]
result = [a + b for a, b in zip_longest(list1, list2, fillvalue=0)]
print(result)  # Output: [5, 7, 3]
```

---

### **Summary**

The `itertools` module is a powerful toolkit for working with iterators. It helps perform complex operations like infinite looping, combinations, or slicing in a memory-efficient way. This makes it especially useful in data processing, mathematical computations, and generating sequences.

## You are given a singly linked list that stores integer values in ascending order. Your task is to determine the time complexity for performing an insertion operation on the numeric value 6 in the given LinkedList

```py
class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def insert_sorted(self, value):
        new_node = Node(value)
        # If the list is empty or the value should be inserted at the head
        if not self.head or self.head.data >= value:
            new_node.next = self.head
            self.head = new_node
            return

        # Traverse the list to find the insertion point
        current = self.head
        while current.next and current.next.data < value:
            current = current.next

        # Insert the new node
        new_node.next = current.next
        current.next = new_node

    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")

# Example usage
linked_list = SinglyLinkedList()
for val in [2, 5, 8, 12]:
    linked_list.insert_sorted(val)

print("Before insertion:")
linked_list.display()

linked_list.insert_sorted(6)

print("After insertion:")
linked_list.display()

```

## Write a Python program that will reverse a string without using the slicing operation or reverse() function.

```py
# Defining the function
def reverseString(x):
    # Declaring an empty string
    NewString = ""
    # Traversing through individual characters in the string
    for i in x:
        # Add the character to the beginning of the new string
        NewString = i + NewString
    # Return the new string
    return NewString

# Sample string
string = "Intellipaat"

# Function call
ReversedString = reverseString(string)

# Printing output
print("Reversed String:", ReversedString)

```

## What is the easiest way to calculate percentiles when using Python?

```py
import numpy as np

a = np.array([1, 2, 3, 4, 5, 6, 7])
p = np.percentile(a, 50) # Returns the 50th percentile, which is also the median
print(p)

```

##  Write a Python program to check whether the given input is an Armstrong number.

## Write a Python program to print a list of primes in a given range.

## Write a program to reverse a list using Enumerate in Python.

## Write a program in Python to execute the Bubble sort algorithm.

## . Write an async function that fetches data from multiple URLs concurrently.
## Write a Python program to count the total number of lines in a text file.

## Write a program in Python to check if a number is prime

## Write a program in Python to produce a Star triangle

## Write a program to produce the Fibonacci series in Python.
## Write a program in Python to find the largest and second-largest element in a list using Python.

## How to remove values from a Python array?