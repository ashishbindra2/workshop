## Python Interview


### **Q1. Difference Between List and Tuple in Python**

| **Aspect**           | **List**                             | **Tuple**                           |
|-----------------------|---------------------------------------|--------------------------------------|
| **Definition**        | List is a Group of Comma separeated Values within Square Brackets and Square Brackets are mandatory. Eg: `i = [10, 20, 30, 40]`.        | Tuple is a Group of Comma separeated Values within Parenthesis and Parenthesis are optional. Eg: `t = (10, 20, 30, 40)` `t = 10, 20, 30, 40.`     |
| **Syntax**            | Defined using square brackets: `[ ]` | Defined using parentheses: `( )`    |
| **Mutability**        | Mutable: Can add, remove, or modify elements. | Immutable: Cannot change after creation. |
| **Performance**       | Slower due to mutability.            | Faster due to immutability.         |
| **Use Case**          | Suitable for collections that may change. | Suitable for fixed collections (e.g., coordinates). |
| **Size**              | Can dynamically grow or shrink.      | Fixed size once created.            |
| **Methods**           | Supports methods like `.append()`, `.remove()`, `.sort()`. | Limited methods: Only `.count()` and `.index()`. |
| **Memory Usage**      | Requires more memory due to dynamic resizing. | More memory-efficient.              |
| **Hashability**       | Not hashable; cannot be used as dictionary keys. | Hashable if all elements are hashable. |
| **Examples**          | `my_list = [1, 2, 3]`               | `my_tuple = (1, 2, 3)`              |

---

### **Key Points**
1. **Mutability**:
   - Lists are mutable, making them ideal for scenarios where data might need to change.
   - Tuples are immutable, ensuring data integrity and better performance in some cases.

2. **When to Use**:
   - Use **lists** when flexibility is needed (e.g., managing a collection of user inputs).
   - Use **tuples** for fixed data (e.g., coordinates, configuration constants).

3. **Hashable Tuples**:
   - A tuple can be used as a key in a dictionary if all its elements are hashable.

---

### **Example: List**
```python
my_list = [1, 2, 3]
my_list.append(4)  # Adds 4 to the list
print(my_list)  # Output: [1, 2, 3, 4]
```

### **Example: Tuple**
```python
my_tuple = (1, 2, 3)
# my_tuple[0] = 10  # Raises a TypeError because tuples are immutable
print(my_tuple)  # Output: (1, 2, 3)
```
In Python, the term **"hashable"** is used to describe an object that has a hash value that remains constant during its lifetime. In the context of dictionaries, hashable objects are critical because they are used as **keys**.

---

### **Q2. What Does Hashable Mean?**
1. **Hash Value**:  
   A hash value is a fixed-size integer that uniquely identifies an object, generated by the `hash()` function.  

2. **Immutability**:  
   To be hashable, an object must be immutable. This ensures that its hash value does not change over time, which is a key requirement for dictionary keys.

3. **Equality and Hashing**:  
   Hashable objects must implement the `__hash__()` method to compute the hash value and the `__eq__()` method for equality checks. Python dictionaries use these methods to organize and retrieve keys efficiently.

---

#### **Why Hashable Is Important for Dictionaries**
- **Key Uniqueness**:  
  Dictionary keys must be unique. Python uses the hash value of a key to quickly determine where to store or find a value in the dictionary.
  
- **Efficient Lookups**:  
  The hash value allows the dictionary to find a key in **O(1)** time complexity on average.

---

#### **Hashable Objects**
Objects that are immutable (and hence hashable) include:
- **Strings**:  
  ```python
  my_dict = {"name": "Alice"}  # 'name' is hashable
  ```
- **Numbers (int, float, etc.)**:  
  ```python
  my_dict = {42: "Answer"}  # 42 is hashable
  ```
- **Tuples (if all elements are hashable)**:  
  ```python
  my_dict = {(1, 2): "coordinates"}  # (1, 2) is hashable
  ```

---

#### **Unhashable Objects**
Objects that are mutable (and hence not hashable) include:
- **Lists**:  
  Lists are mutable and cannot be used as dictionary keys.  
  ```python
  my_dict = {[1, 2]: "List"}  # Raises TypeError: unhashable type: 'list'
  ```
  
- **Sets**:  
  Like lists, sets are mutable and unhashable.  
  ```python
  my_dict = {set([1, 2]): "Set"}  # Raises TypeError
  ```

---

#### **Custom Hashable Objects**
You can make a custom object hashable by defining the `__hash__()` and `__eq__()` methods.

#### Example:
```python
class MyHashableClass:
    def __init__(self, value):
        self.value = value

    def __hash__(self):
        return hash(self.value)  # Use the hash of 'value'

    def __eq__(self, other):
        return isinstance(other, MyHashableClass) and self.value == other.value

# Using custom hashable object as dictionary key
key = MyHashableClass(42)
my_dict = {key: "Custom Object"}
print(my_dict[key])  # Output: Custom Object
```

---

#### **Key Points in the Context of Dictionaries**
1. A dictionary key **must be hashable**.
2. Hashable objects allow Python to store dictionary keys in a hash table for fast lookups.
3. If you attempt to use an unhashable object as a key, Python will raise a `TypeError`.

#### Example:
```python
# Hashable example
hashable_key = "name"
my_dict = {hashable_key: "Alice"}
print(my_dict[hashable_key])  # Output: Alice

# Unhashable example
unhashable_key = [1, 2, 3]  # A list
my_dict = {unhashable_key: "List"}  # Raises TypeError
```

By ensuring that objects used as dictionary keys are hashable, Python maintains the efficiency and reliability of its dictionary implementation.


### **Q3. Difference Between `pop()` and `remove()` in Python**

| **Aspect**           | **`pop()`**                                      | **`remove()`**                                  |
|-----------------------|--------------------------------------------------|------------------------------------------------|
| **Functionality**     | Removes an element by its **index**.             | Removes an element by its **value**.           |
| **Parameters**        | Takes an optional index as an argument.          | Takes the value of the element as an argument. |
| **Return Value**      | Returns the removed element.                     | Does not return the removed element.           |
| **Default Behavior**  | If no index is provided, removes the last element. | Must specify the value to remove.              |
| **Error Handling**    | Raises an `IndexError` if the list is empty or index is out of range. | Raises a `ValueError` if the value is not found. |
| **Mutability**        | Modifies the original list.                      | Modifies the original list.                    |

---

#### **Example: `pop()`**

```python
# Using pop() with and without an index
my_list = [10, 20, 30, 40, 50]

# Remove and return the last element
removed_item = my_list.pop()
print(removed_item)  # Output: 50
print(my_list)       # Output: [10, 20, 30, 40]

# Remove and return the element at index 1
removed_item = my_list.pop(1)
print(removed_item)  # Output: 20
print(my_list)       # Output: [10, 30, 40]
```

---

#### **Example: `remove()`**

```python
# Using remove() to remove an element by value
my_list = [10, 20, 30, 40, 50]

# Remove the element with value 30
my_list.remove(30)
print(my_list)  # Output: [10, 20, 40, 50]

# Remove a value that doesn't exist (raises ValueError)
# my_list.remove(100)  # Raises ValueError: list.remove(x): x not in list
```

---

#### **Key Differences**
1. **Index vs Value**:
   - `pop()` removes an element based on its position (index).
   - `remove()` removes the first occurrence of a specific value.

2. **Return Value**:
   - `pop()` returns the removed element.
   - `remove()` does not return the removed element.

3. **Default Behavior**:
   - `pop()` without an index removes the last element.
   - `remove()` always requires a value to specify which element to remove.

---

#### **When to Use**
- Use `**pop()**` when:
  - You need to remove an element by index or retrieve the removed element.
- Use `**remove()**` when:
  - You know the value to be removed but not its index.


### Q4. Write a Python function that will reverse a string without using the slicing operation or reverse() function.

```py title="using for loop"
def reverse_string(data: str)-> str:
  result = ""
  for char in data:
    result = char + result
  return result

reverse_string("Testing a string")
```

```py title="using while loop"
text: str = "Ashish"
def reverse_string(text: str)-> str:
    n = len(text)-1
    result = ''
    while n>=0 :
        result= result + text[n]
        n-=1
    return result
print(reverse_string(text))
```
### Q5. Write a program to delete all constants from a given string. "Python and Data Science"

```py
def return_string(data):
  vowels = 'aeiouAEIOU'
  result = ''.join([char for char in data if not char.isalpha() or char in vowels])
  return result

return_string(data ="Python and Data Science")

```

### Q6. Write a program that will find sum of all the prime between 1 to N.
```py
def is_prime(number):
  for i in range(2,number):
    if(number % i ==0):
      return False
    return True

def add(number):
  total = 0
  for i in range(2,number + 1):
    if is_prime(i):
      total = total + i
  return total
print(add(10))
```

### Q7. What is a Generator in Python?
A generator in Python is a special type of iterable that produces values one at a time using the yield keyword, rather than creating and storing all values in memory at once. 
- Generators are a memory-efficient way to handle large datasets or infinite sequences.


### **Creating Generators**

#### **1. Generator Function**
- Generator is a function which is responsible to generate a sequence of values.
- We can write generator functions just like ordinary functions, but it uses yield keyword to return values

A function that uses the `yield` keyword to produce values one at a time.

```python
def my_generator():
    for i in range(5):
        yield i

# Using the generator
gen = my_generator()
print(next(gen))  # Output: 0
print(next(gen))  # Output: 1

for value in gen:
    print(value)  # Output: 2, 3, 4
```

#### **2. Generator Expression**
A compact way to create a generator, similar to list comprehensions but with parentheses instead of square brackets.

```python
gen = (x**2 for x in range(5))

print(next(gen))  # Output: 0
print(next(gen))  # Output: 1

for value in gen:
    print(value)  # Output: 4, 9, 16
```

---

### **Difference Between Generators and Lists**

| **Aspect**        | **Generator**                                      | **List**                                 |
|--------------------|---------------------------------------------------|------------------------------------------|
| **Memory Usage**   | Memory-efficient; generates values on the fly.    | Stores all elements in memory.           |
| **Performance**    | Faster for large datasets or infinite sequences.  | Slower for large datasets due to memory overhead. |
| **Modification**   | Cannot modify elements once created.              | Can modify elements.                     |

---

### **Advantages of Generators**
1. **Memory Efficiency**:
   - Suitable for working with large datasets or streams of data.
2. **Improved Performance**:
   - No need to compute all elements upfront; computation happens only when needed.
3. **Simplified Code**:
   - Easily represent infinite sequences (e.g., Fibonacci series, prime numbers).

---

### **Use Case Example: Generator for Infinite Sequence**

```python
def infinite_numbers():
    num = 0
    while True:
        yield num
        num += 1

gen = infinite_numbers()

print(next(gen))  # Output: 0
print(next(gen))  # Output: 1
print(next(gen))  # Output: 2
```
#### Generators vs Normal Collections wrt performance:
```py

import random
import time
names = ['Sunny','Bunny','Chinny','Vinny']
subjects = ['Python','Java','Blockchain']

def people_list(num_people):
  results = []
  for i in range(num_people):
    person = {
      'id':i,
      'name': random.choice(names),
      'subject':random.choice(subjects)
    }
  results.append(person)
  return results
t1 = time.time()
people = people_list(10000000)
t2 = time.time()
print(f'Took {t2-t1}')

def people_generator(num_people):
  for i in range(num_people):
    person = {
      'id':i,
      'name': random.choice(names),
      'major':random.choice(subjects)
      }
  yield person

t1 = time.time()
people = people_generator(10000000)
t2 = time.time()

print(f'Took {t2-t1}')

```
#### Generators vs Normal Collections wrt Memory Utilization:

Normal Collection:

```py
l=[x*x for x in range(10000000000000000)]
print(l[0])
```
> We will get MemoryError in this case because all these values are required to store in the memory.

Generators:

```py
g=(x*x for x in range(10000000000000000))
print(next(g))
Output: 0
```

>We won't get any MemoryError because the values won't be stored at the beginning
---

### **Conclusion**
Generators are a powerful tool for creating efficient, iterable objects that avoid memory overhead. Use them when working with large datasets, streaming data, or infinite sequences to improve performance and resource usage.


> create speed of function execting genrator

### Q8. What is decorator? Multiple decorator
### **What is a Decorator in Python?**

A **decorator** in Python is a function that modifies the behavior of another function or method. It allows you to "wrap" another function to add or alter its functionality without changing its structure or code.

---

### **How Decorators Work**

1. A decorator takes a function as an argument.
2. It defines a nested wrapper function that modifies or enhances the behavior of the original function.
3. The wrapper function is returned and replaces the original function.

#### **Syntax**
```python
@decorator_name
def function_to_decorate():
    pass
```

The `@decorator_name` syntax is equivalent to:
```python
function_to_decorate = decorator_name(function_to_decorate)
```

---

### **Single Decorator Example**
```python
# Define a decorator
def greet_decorator(func):
    def wrapper(name):
        print("Hello!")
        func(name)
        print("Goodbye!")
    return wrapper

# Apply the decorator
@greet_decorator
def say_name(name):
    print(f"My name is {name}.")

# Call the function
say_name("Ashish")
```
**Output**:
```
Hello!
My name is Ashish.
Goodbye!
```

---

### **Multiple Decorators**

You can stack multiple decorators on a single function by applying them one after the other.

#### **Example of Multiple Decorators**
```python
# Define decorators
def bold_decorator(func):
    def wrapper():
        return f"<b>{func()}</b>"
    return wrapper

def italic_decorator(func):
    def wrapper():
        return f"<i>{func()}</i>"
    return wrapper

# Apply multiple decorators
@bold_decorator
@italic_decorator
def get_text():
    return "Hello, World!"

# Call the function
print(get_text())
```
**Output**:
```
<b><i>Hello, World!</i></b>
```

**Explanation**:
1. The `italic_decorator` is applied first, wrapping the function output in `<i>`.
2. The `bold_decorator` is applied next, wrapping the result of the first decorator in `<b>`.

---

### **Key Points About Multiple Decorators**
1. **Order of Execution**:
   - Decorators are applied from the bottom to the top, but their effects are executed from the top down.
   - In the above example:
     - `italic_decorator` wraps the original function.
     - `bold_decorator` wraps the result of `italic_decorator`.

2. **Use Cases**:
   - You might stack multiple decorators for logging, validation, access control, or formatting.

---

### **Practical Use Cases of Decorators**

1. **Logging**:
   Add logging functionality to a function.
   ```python
   def log_decorator(func):
       def wrapper(*args, **kwargs):
           print(f"Calling function: {func.__name__}")
           return func(*args, **kwargs)
       return wrapper
   ```

2. **Access Control**:
   Restrict access to specific users or roles.
   ```python
   def admin_only(func):
       def wrapper(user):
           if user != "admin":
               print("Access Denied!")
           else:
               func(user)
       return wrapper

   @admin_only
   def view_admin_dashboard(user):
       print("Welcome to the admin dashboard!")
   ```

3. **Formatting Output**:
   Format the output of a function for display or use in templates.

---

Decorators are a powerful and flexible way to add functionality to your code in a clean and reusable manner. Multiple decorators help in stacking behaviors efficiently.

```py
def love(fun):
  def inner():
    return fun.__name__
  return inner
@love
def fun_test():
  print("testing")

print(fun_test())  
```
```py 
def dob(fun):
  def inner(n):
    return fun(n**2)
  return inner

def calc(num):
  print(num)

@dob
def cal(num):
  print(num)

calc(11)
cal(11)
```

Q9. What is list comprehension? write some sample code? what is use of it?
### **What is List Comprehension in Python?**

List comprehension is a concise and elegant way to create lists in Python. It uses a single line of code to generate a new list by applying an expression to each item in an existing iterable. 

---

### **Syntax of List Comprehension**

```python
[expression for item in iterable if condition]
```

1. **Expression**: An operation or transformation applied to each item in the iterable.
2. **Item**: The variable that takes the value of each element from the iterable.
3. **Iterable**: The data source (e.g., list, range, string, etc.).
4. **Condition (optional)**: A filtering condition that determines whether an item should be included.

---

### **Uses of List Comprehension**
1. **Simplifies Code**: Reduces multiple lines of code into one concise statement.
2. **Readable**: Improves code readability for simple list transformations.
3. **Efficient**: Faster than traditional `for` loops for small to medium-sized datasets.

---

### **Examples of List Comprehension**

#### **1. Basic List Creation**
```python
# Create a list of squares
squares = [x**2 for x in range(5)]
print(squares)  # Output: [0, 1, 4, 9, 16]
```

#### **2. With Filtering (Condition)**
```python
# Create a list of even numbers
evens = [x for x in range(10) if x % 2 == 0]
print(evens)  # Output: [0, 2, 4, 6, 8]
```

#### **3. Nested Loops**
```python
# Create a list of coordinate pairs
coordinates = [(x, y) for x in range(3) for y in range(2)]
print(coordinates)  # Output: [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)]
```

#### **4. Applying a Function**
```python
# Convert all strings in a list to uppercase
words = ["hello", "world", "python"]
uppercase_words = [word.upper() for word in words]
print(uppercase_words)  # Output: ['HELLO', 'WORLD', 'PYTHON']
```

#### **5. Conditional Transformation**
```python
# Replace negative numbers with 0
nums = [-1, 2, -3, 4]
non_negative = [x if x >= 0 else 0 for x in nums]
print(non_negative)  # Output: [0, 2, 0, 4]
```

#### **6. Flattening a Nested List**
```python
# Flatten a 2D list
matrix = [[1, 2], [3, 4], [5, 6]]
flattened = [num for row in matrix for num in row]
print(flattened)  # Output: [1, 2, 3, 4, 5, 6]
```

---

### **Advantages of List Comprehension**
- Concise and expressive.
- Avoids the need for explicit loops.
- Easy to read and understand for simple operations.

---

### **When to Avoid List Comprehension**
- When the logic is complex and includes multiple conditions or operations, traditional loops may be more readable.
- For very large datasets, using list comprehension may lead to high memory usage as it creates the entire list in memory.

---

### **Summary**
List comprehension is a powerful and elegant way to generate and manipulate lists in Python. It is particularly useful for creating new lists based on existing iterables in a concise and efficient manner.
#### Q. Write a program to display unique vowels present in the given word?
```py
vowels = ['a', 'e', 'i', 'o', 'u']
word = input("Enter the word to search for vowels: ")

# Using list comprehension to find unique vowels in the word
found = [letter for letter in vowels if letter in word]

print(found)
print(f"The number of different vowels present in '{word}' is {len(found)}")

```
Q10. Write code of fibonacci series?
```py
def fib():
  a,b = 0,1
  while True:
    yield a
    a,b = b,a+b
data = fib()
for _ in range(11):
  print(next(data))
```
```py
# Fibonacci series using generator
def fibonacci_generator(n):
    a, b = 0, 1
    for _ in range(n):
        yield a
        a, b = b, a + b

# Input: Number of terms
num_terms = int(input("Enter the number of terms: "))
print(f"Fibonacci series: {list(fibonacci_generator(num_terms))}")

```

Q11. What is dictionary? is this accept duplicate or not?
Q20. program to reverse dictionary key to value and value to key
Here’s a Python program to reverse the keys and values of a dictionary:

### **Program**
```python
# Original dictionary
original_dict = {
    "name": "Ashish",
    "age": 25,
    "course": "Python"
}

# Reversing the dictionary
reversed_dict = {value: key for key, value in original_dict.items()}

# Output the result
print("Original Dictionary:", original_dict)
print("Reversed Dictionary:", reversed_dict)
```

---

### **Output**
```
Original Dictionary: {'name': 'Ashish', 'age': 25, 'course': 'Python'}
Reversed Dictionary: {'Ashish': 'name', 25: 'age', 'Python': 'course'}
```

---

### **Explanation**
1. **`original_dict.items()`**: Provides an iterable of key-value pairs from the original dictionary.
2. **Dictionary Comprehension**: Swaps the keys and values by creating a new dictionary where:
   - `key` becomes `value`
   - `value` becomes `key`

---

### **Considerations**
- **Duplicate Values in the Original Dictionary**: If there are duplicate values in the original dictionary, the reversed dictionary will only keep one of the original keys (the last one processed). For example:
  ```python
  original_dict = {"a": 1, "b": 2, "c": 1}
  reversed_dict = {value: key for key, value in original_dict.items()}
  print(reversed_dict)  # Output: {1: 'c', 2: 'b'}
  ```
  The key `'a'` is overwritten by `'c'` for the value `1`.

- **Immutable Values**: Only hashable and immutable values in the original dictionary can be used as keys in the reversed dictionary. If a value is mutable (like a list), it will raise a `TypeError`.
Q21. what lambda function with example
### **What is a Lambda Function in Python?**

A **lambda function** in Python is a small, anonymous function defined using the `lambda` keyword. It can have any number of input arguments but only one expression. The result of the expression is automatically returned.

---

### **Syntax**
```python
lambda arguments: expression
```

- **`arguments`**: Input parameters, like a regular function.
- **`expression`**: The computation or operation to perform and return.

---

### **Key Characteristics**
1. Anonymous: Lambda functions don't have a name (unlike normal functions defined using `def`).
2. Single Expression: They consist of only one expression, and the result is implicitly returned.
3. Typically used for short, simple operations.

---

### **Examples**

#### **1. Simple Lambda Function**
```python
# Lambda function to add two numbers
add = lambda x, y: x + y
print(add(5, 3))  # Output: 8
```

---

#### **2. Lambda Function Inside Another Function**
```python
# Function using a lambda to square a number
def square(n):
    return (lambda x: x ** 2)(n)

print(square(4))  # Output: 16
```

---

#### **3. Using Lambda with `map()`**
```python
# Doubling all numbers in a list
nums = [1, 2, 3, 4, 5]
doubled = list(map(lambda x: x * 2, nums))
print(doubled)  # Output: [2, 4, 6, 8, 10]
```

---

#### **4. Using Lambda with `filter()`**
```python
# Filtering even numbers from a list
nums = [1, 2, 3, 4, 5]
even_nums = list(filter(lambda x: x % 2 == 0, nums))
print(even_nums)  # Output: [2, 4]
```

---

#### **5. Using Lambda with `sorted()`**
```python
# Sorting a list of tuples by the second element
data = [(1, 'b'), (2, 'a'), (3, 'c')]
sorted_data = sorted(data, key=lambda x: x[1])
print(sorted_data)  # Output: [(2, 'a'), (1, 'b'), (3, 'c')]
```

---

### **When to Use Lambda Functions**
1. For small, quick operations.
2. As an argument to functions like `map()`, `filter()`, and `sorted()`.
3. When defining functions inline without needing a formal function name.

---

### **Limitations of Lambda Functions**
1. **Single Expression**: Lambdas are limited to one expression, so they're not suitable for complex logic.
2. **No Name**: Debugging and reusability can be harder because they're anonymous.
3. **No Statements**: Cannot contain statements like `if`, `for`, or `print` (only expressions).

---

### **Comparison with Regular Function**
```python
# Regular function
def add(x, y):
    return x + y

# Equivalent lambda function
add_lambda = lambda x, y: x + y
```

Both can be used interchangeably, but lambda is concise and often used for inline or short-lived operations.

### **`map()`, `filter()`, and `sorted()` in Python**

These are built-in Python functions commonly used for applying operations to collections like lists, tuples, or sets. They allow for efficient, functional-style operations.

---

### **1. `map()`**
The `map()` function applies a given function to each item in an iterable and returns a new iterable (a `map` object).

#### **Syntax**
```python
map(function, iterable)
```

- **`function`**: A function to apply to each element of the iterable.
- **`iterable`**: The collection (like a list, tuple) whose items the function will process.

#### **Example**
```python
# Doubling each number in a list
nums = [1, 2, 3, 4]
doubled = list(map(lambda x: x * 2, nums))
print(doubled)  # Output: [2, 4, 6, 8]
```

#### **Use Cases**
- Transforming data in a collection.
- Applying mathematical or custom operations on each element.

---

### **2. `filter()`**
The `filter()` function filters elements from an iterable based on a condition defined by a function. It returns a new iterable (a `filter` object) containing elements where the function evaluates to `True`.

#### **Syntax**
```python
filter(function, iterable)
```

- **`function`**: A function that returns `True` or `False` for each element.
- **`iterable`**: The collection to filter.

#### **Example**
```python
# Filtering even numbers from a list
nums = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # Output: [2, 4, 6]
```

#### **Use Cases**
- Extracting elements that meet a specific condition.
- Filtering data like even numbers, strings that match a pattern, etc.

---

### **3. `sorted()`**
The `sorted()` function sorts the elements of an iterable and returns a new sorted list.

#### **Syntax**
```python
sorted(iterable, key=None, reverse=False)
```

- **`iterable`**: The collection to be sorted.
- **`key`** *(optional)*: A function defining the sorting logic (e.g., based on length or specific property).
- **`reverse`** *(optional)*: If `True`, sorts in descending order; otherwise, ascending (default).

#### **Example**
```python
# Sorting numbers in ascending and descending order
nums = [5, 2, 9, 1, 3]
print(sorted(nums))               # Output: [1, 2, 3, 5, 9]
print(sorted(nums, reverse=True)) # Output: [9, 5, 3, 2, 1]

# Sorting strings by length
words = ["apple", "banana", "kiwi"]
sorted_by_length = sorted(words, key=len)
print(sorted_by_length)  # Output: ['kiwi', 'apple', 'banana']
```

#### **Use Cases**
- Sorting data numerically, alphabetically, or based on custom criteria.
- Rearranging complex data like dictionaries, tuples, or custom objects.

---

### **Summary of Differences**

| **Function** | **Purpose**                                        | **Returns**       | **Use Case**                                |
|--------------|----------------------------------------------------|-------------------|---------------------------------------------|
| `map()`      | Applies a function to every element of an iterable | A `map` object    | Transform all elements of a collection      |
| `filter()`   | Filters elements based on a condition              | A `filter` object | Extract specific elements from a collection |
| `sorted()`   | Sorts elements based on criteria                   | A list            | Arrange elements in a specific order        |

These functions are integral for efficient data processing and align well with functional programming styles in Python.
Q22. Can you convert List to Dict object. (Scenario)
> Yes, you can convert a list to a dictionary in Python. However, how you do this depends on the structure of the list and the desired format of the dictionary. Here are a few common scenarios:

---

### **1. Convert a List of Tuples to a Dictionary**
If the list contains tuples where the first element is the key and the second is the value, you can use the `dict()` constructor.

```python
# List of tuples
list_of_tuples = [("a", 1), ("b", 2), ("c", 3)]

# Convert to dictionary
dict_obj = dict(list_of_tuples)
print(dict_obj)
```

**Output:**
```
{'a': 1, 'b': 2, 'c': 3}
```

---

### **2. Convert Two Lists (Keys and Values) into a Dictionary**
If you have two lists — one for keys and one for values — you can use the `zip()` function.

```python
# Lists of keys and values
keys = ["name", "age", "city"]
values = ["Alice", 25, "New York"]

# Convert to dictionary
dict_obj = dict(zip(keys, values))
print(dict_obj)
```

**Output:**
```
{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

---

### **3. Convert a List of Elements into a Dictionary with Indices as Keys**
If you want to use the indices of the list elements as dictionary keys, you can use `enumerate()`.

```python
# List of values
values = ["Apple", "Banana", "Cherry"]

# Convert to dictionary
dict_obj = {index: value for index, value in enumerate(values)}
print(dict_obj)
```

**Output:**
```
{0: 'Apple', 1: 'Banana', 2: 'Cherry'}
```

---

### **4. Convert a Flat List into a Dictionary**
If the list alternates between keys and values, you can use slicing or the `zip()` function.

```python
# Flat list with alternating keys and values
flat_list = ["name", "Alice", "age", 25, "city", "New York"]

# Convert to dictionary
dict_obj = dict(zip(flat_list[0::2], flat_list[1::2]))
print(dict_obj)
```

**Output:**
```
{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

---

### **5. Custom Conversion Logic**
If the list has a custom structure, you can use a loop or a dictionary comprehension to process it.

```python
# List of items
list_items = ["name", "Alice", "age", 25, "city", "New York"]

# Convert to dictionary (even indices are keys, odd indices are values)
dict_obj = {list_items[i]: list_items[i + 1] for i in range(0, len(list_items), 2)}
print(dict_obj)
```

**Output:**
```
{'name': 'Alice', 'age': 25, 'city': 'New York'}
```

---

### **General Notes**
1. **Duplicate Keys**: If the list contains duplicate keys (e.g., in case of a list of tuples), only the last key-value pair is retained in the dictionary.
2. **Invalid Data Structure**: If the list structure doesn't match the intended dictionary format (e.g., an odd number of elements in the flat list), you’ll need to handle such cases with error-checking or default values.
Q23. Diff between extend & append in list
### **Difference Between `extend()` and `append()` in Python Lists**

Both `extend()` and `append()` are methods used to add elements to a list in Python, but they behave differently.

---

### **1. `append()`**

- **Purpose**: Adds a single element to the end of the list.
- **Behavior**: Treats the argument as a single item, even if it is iterable (like a list or tuple).
- **Returns**: Does not return a new list; modifies the list in place.
  
#### **Example:**
```python
# Original list
my_list = [1, 2, 3]

# Append an element
my_list.append(4)
print(my_list)  # Output: [1, 2, 3, 4]

# Append a list as a single element
my_list.append([5, 6])
print(my_list)  # Output: [1, 2, 3, 4, [5, 6]]
```

---

### **2. `extend()`**

- **Purpose**: Extends the list by appending each element from the iterable (like another list or tuple) to the list.
- **Behavior**: Breaks the iterable into individual elements and adds them to the list.
- **Returns**: Does not return a new list; modifies the list in place.

#### **Example:**
```python
# Original list
my_list = [1, 2, 3]

# Extend the list with another list
my_list.extend([4, 5])
print(my_list)  # Output: [1, 2, 3, 4, 5]

# Extend the list with a tuple
my_list.extend((6, 7))
print(my_list)  # Output: [1, 2, 3, 4, 5, 6, 7]
```

---

### **Key Differences**

| **Feature**       | **`append()`**                      | **`extend()`**                          |
|--------------------|-------------------------------------|-----------------------------------------|
| **Argument**       | Takes a single element (any type). | Takes an iterable (e.g., list, tuple).  |
| **Behavior**       | Adds the entire element as-is.     | Adds each element of the iterable.      |
| **Effect**         | Increases the list length by 1.    | Increases the list length by the size of the iterable. |
| **Result**         | Adds nested lists or iterables.    | Flattens the iterable into the list.    |

---

### **Example Comparison**
```python
# Using append()
list1 = [1, 2, 3]
list1.append([4, 5])
print(list1)  # Output: [1, 2, 3, [4, 5]]

# Using extend()
list2 = [1, 2, 3]
list2.extend([4, 5])
print(list2)  # Output: [1, 2, 3, 4, 5]
```

---

### **When to Use?**

- Use **`append()`** when you want to add a single element or when adding an entire object (like a list) as a single item.
- Use **`extend()`** when you want to add multiple elements from an iterable to the list individually.

These methods make list manipulations more versatile and efficient depending on the task.
Q13. What are the main principles of oops?
Q14. Explain type of inheritance
Q15. What is aws lambda function
Q16. Explain your project briefly
Q17. regular expression for email validation
### **Regular Expression for Email Validation**

A regular expression (regex) can be used to validate email addresses by ensuring they conform to a specific pattern. Here's an example of a commonly used regex for email validation:

```python
import re

# Define a regex pattern for email validation
email_regex = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

# Sample email validation function
def validate_email(email):
    if re.match(email_regex, email):
        return True
    return False

# Test the function
print(validate_email("example@test.com"))  # Output: True
print(validate_email("invalid-email"))     # Output: False
```

---

### **Explanation of the Regex Pattern**
```regex
^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$
```

| **Component**          | **Meaning**                                                                 |
|-------------------------|-----------------------------------------------------------------------------|
| `^`                    | Start of the string.                                                       |
| `[a-zA-Z0-9._%+-]+`     | Matches the local part of the email (before the `@`). Can contain letters, digits, dots (`.`), underscores (`_`), percent signs (`%`), plus (`+`), and hyphens (`-`). |
| `@`                    | Matches the `@` symbol separating the local part and the domain.            |
| `[a-zA-Z0-9.-]+`        | Matches the domain name (e.g., `gmail`, `yahoo`). Can contain letters, digits, dots (`.`), and hyphens (`-`). |
| `\.`                   | Matches the dot (`.`) separating the domain and top-level domain (TLD).     |
| `[a-zA-Z]{2,}`          | Matches the top-level domain (TLD) with at least 2 characters (e.g., `com`, `org`). |
| `$`                    | End of the string.                                                         |

---

### **Examples of Valid and Invalid Emails**

#### **Valid Emails**
1. `example@test.com`
2. `user.name+tag+sorting@example.com`
3. `x@example.org`
4. `email@subdomain.example.com`

#### **Invalid Emails**
1. `plainaddress` (No `@` symbol)
2. `@missingusername.com` (No local part)
3. `username@.com` (Domain is missing)
4. `username@domain` (No TLD)

---

### **Important Notes**
- This regex is a basic implementation and covers most use cases.
- Some valid emails might not match this regex (e.g., unusual but technically valid domain names).
- For stricter validation or internationalized email addresses, consider libraries like **`email-validator`**:
  ```bash
  pip install email-validator
  ```
  ```python
  from email_validator import validate_email, EmailNotValidError

  try:
      valid = validate_email("example@test.com")
      print("Valid Email:", valid.email)
  except EmailNotValidError as e:
      print("Invalid Email:", str(e))
  ```
Q18. How to define private and public variables
Q19. convert list to pandas dataframe 

Q24. Define a class. SDLC models 
Q25. Asked to describe iterators in Python, and implement it 
Q26. Asked about generators? Asked how I implemented Python in my project
Q27. datatypes in python
Q28. SLice , list , dict , django, CROSS, API
Q29. Midlewares, session,cookies,APIs,oops
Q30. Reverse character string in python
Q32. map
### **`map()`, `filter()`, and `sorted()` in Python**

These are built-in Python functions commonly used for applying operations to collections like lists, tuples, or sets. They allow for efficient, functional-style operations.

---

### **1. `map()`**
The `map()` function applies a given function to each item in an iterable and returns a new iterable (a `map` object).

#### **Syntax**
```python
map(function, iterable)
```

- **`function`**: A function to apply to each element of the iterable.
- **`iterable`**: The collection (like a list, tuple) whose items the function will process.

#### **Example**
```python
# Doubling each number in a list
nums = [1, 2, 3, 4]
doubled = list(map(lambda x: x * 2, nums))
print(doubled)  # Output: [2, 4, 6, 8]
```

#### **Use Cases**
- Transforming data in a collection.
- Applying mathematical or custom operations on each element.

---

### **2. `filter()`**
The `filter()` function filters elements from an iterable based on a condition defined by a function. It returns a new iterable (a `filter` object) containing elements where the function evaluates to `True`.

#### **Syntax**
```python
filter(function, iterable)
```

- **`function`**: A function that returns `True` or `False` for each element.
- **`iterable`**: The collection to filter.

#### **Example**
```python
# Filtering even numbers from a list
nums = [1, 2, 3, 4, 5, 6]
evens = list(filter(lambda x: x % 2 == 0, nums))
print(evens)  # Output: [2, 4, 6]
```

#### **Use Cases**
- Extracting elements that meet a specific condition.
- Filtering data like even numbers, strings that match a pattern, etc.

---

### **3. `sorted()`**
The `sorted()` function sorts the elements of an iterable and returns a new sorted list.

#### **Syntax**
```python
sorted(iterable, key=None, reverse=False)
```

- **`iterable`**: The collection to be sorted.
- **`key`** *(optional)*: A function defining the sorting logic (e.g., based on length or specific property).
- **`reverse`** *(optional)*: If `True`, sorts in descending order; otherwise, ascending (default).

#### **Example**
```python
# Sorting numbers in ascending and descending order
nums = [5, 2, 9, 1, 3]
print(sorted(nums))               # Output: [1, 2, 3, 5, 9]
print(sorted(nums, reverse=True)) # Output: [9, 5, 3, 2, 1]

# Sorting strings by length
words = ["apple", "banana", "kiwi"]
sorted_by_length = sorted(words, key=len)
print(sorted_by_length)  # Output: ['kiwi', 'apple', 'banana']
```

#### **Use Cases**
- Sorting data numerically, alphabetically, or based on custom criteria.
- Rearranging complex data like dictionaries, tuples, or custom objects.

---

### **Summary of Differences**

| **Function** | **Purpose**                                        | **Returns**       | **Use Case**                                |
|--------------|----------------------------------------------------|-------------------|---------------------------------------------|
| `map()`      | Applies a function to every element of an iterable | A `map` object    | Transform all elements of a collection      |
| `filter()`   | Filters elements based on a condition              | A `filter` object | Extract specific elements from a collection |
| `sorted()`   | Sorts elements based on criteria                   | A list            | Arrange elements in a specific order        |

These functions are integral for efficient data processing and align well with functional programming styles in Python.x  
Q33. filter
Q34. tertools (Advanced Iterators)
### **`itertools` (Advanced Iterators) in Python**

The **`itertools`** module in Python provides a set of fast, memory-efficient tools for working with iterators. These tools allow you to create complex iterators for handling combinatorics, permutations, combinations, and more. It's part of Python's standard library.

---

### **Key Features**
1. Efficient iteration over large data sets without loading everything into memory.
2. Provides advanced functions for:
   - Infinite iterators
   - Iterators for combinations and permutations
   - Utility functions for iterator manipulation

---

### **Categories of Functions**

#### **1. Infinite Iterators**
These iterators produce values indefinitely and are useful for repetitive tasks.

- **`itertools.count(start=0, step=1)`**: Generates an infinite sequence starting at `start` and incremented by `step`.
  ```python
  from itertools import count
  for num in count(5, 2):  # Starts at 5, increments by 2
      if num > 15:
          break
      print(num)  # Output: 5, 7, 9, 11, 13, 15
  ```

- **`itertools.cycle(iterable)`**: Cycles through an iterable indefinitely.
  ```python
  from itertools import cycle
  counter = 0
  for item in cycle(['A', 'B', 'C']):
      if counter > 5:
          break
      print(item)  # Output: A, B, C, A, B, C
      counter += 1
  ```

- **`itertools.repeat(object, times=None)`**: Repeats an object a fixed number of times (or indefinitely if `times` is not specified).
  ```python
  from itertools import repeat
  for item in repeat("Hello", 3):
      print(item)  # Output: Hello, Hello, Hello
  ```

---

#### **2. Combinatoric Iterators**
Generate permutations, combinations, or Cartesian products.

- **`itertools.permutations(iterable, r=None)`**: Generates all possible permutations of `r` elements from the iterable.
  ```python
  from itertools import permutations
  for perm in permutations([1, 2, 3], 2):
      print(perm)  # Output: (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)
  ```

- **`itertools.combinations(iterable, r)`**: Generates all possible combinations of `r` elements from the iterable.
  ```python
  from itertools import combinations
  for comb in combinations([1, 2, 3], 2):
      print(comb)  # Output: (1, 2), (1, 3), (2, 3)
  ```

- **`itertools.product(*iterables, repeat=1)`**: Generates the Cartesian product of input iterables.
  ```python
  from itertools import product
  for prod in product([1, 2], ['A', 'B']):
      print(prod)  # Output: (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')
  ```

---

#### **3. Utility Iterators**
Helpers for combining, grouping, or slicing iterators.

- **`itertools.chain(*iterables)`**: Combines multiple iterables into a single iterator.
  ```python
  from itertools import chain
  for item in chain([1, 2], ['A', 'B']):
      print(item)  # Output: 1, 2, A, B
  ```

- **`itertools.islice(iterable, start, stop, step)`**: Slices an iterable.
  ```python
  from itertools import islice
  for item in islice(range(10), 2, 8, 2):
      print(item)  # Output: 2, 4, 6
  ```

- **`itertools.groupby(iterable, key=None)`**: Groups items in an iterable by a key function.
  ```python
  from itertools import groupby
  data = [("cat", 1), ("cat", 2), ("dog", 3), ("dog", 4)]
  for key, group in groupby(data, lambda x: x[0]):
      print(key, list(group))  
      # Output: 
      # cat [('cat', 1), ('cat', 2)]
      # dog [('dog', 3), ('dog', 4)]
  ```

---

### **Advantages**
1. **Memory Efficiency**: Operates lazily, producing values on demand instead of storing them in memory.
2. **Combinatoric Power**: Simplifies tasks like generating permutations, combinations, or Cartesian products.
3. **Enhanced Productivity**: Provides many ready-to-use tools that reduce the need for custom implementations.

---

### **Real-World Example**
**Summing two lists element-wise using `itertools.zip_longest`:**
```python
from itertools import zip_longest

list1 = [1, 2, 3]
list2 = [4, 5]
result = [a + b for a, b in zip_longest(list1, list2, fillvalue=0)]
print(result)  # Output: [5, 7, 3]
```

---

### **Summary**
The `itertools` module is a powerful toolkit for working with iterators. It helps perform complex operations like infinite looping, combinations, or slicing in a memory-efficient way. This makes it especially useful in data processing, mathematical computations, and generating sequences.